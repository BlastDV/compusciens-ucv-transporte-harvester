/*******************************************************************
$Header: C:/Symbol/Csp32Proj/Csp32/src/vcs/Csp32.cpv  1.0  05 Mar 1999  10:00:00 kFallon $
 *
 * © Copyright 1999 Peninsula Solutions, Inc., all rights reserved.
 * © Copyright 1999 Symbol Technologies, Inc., all rights reserved.
 *
 *          ***************************************
 *          * This file was generated by:         *
 *          *       Peninsula Solutions, Inc.     *
 *          *       1265 S. Semoran Blvd.         *
 *          *       Suite 1247                    *
 *          *       Winter Park, FL 32792         *
 *          *       Phone: (407) 673-6544         *
 *          *       Fax:   (407) 673-6545         *
 *          * E-mail: info@PeninsulaSolutions.com *
 *          *                                     *
 *          * under a grant from:                 *
 *          *       Symbol Technologies, Inc.     *
 *          *       Holtsville, NY                *
 *          ***************************************
 *
 * The user is granted a license to use and modify this file for their own
 * purposes so long as the Copyright information remains intact.
 *
 *    MODULE NAME:   Csp32.cpp
 *
 *    DESCRIPTION:
 *                   This file provides the user API interface
 *                   functions for Symbol's Consumer Scanning
 *                   Products as Dynamic Link Library. When
 *                   compiled into a DLL, the user can access
 *                   all of the functions available for the
 *                   Symbol CyberPen.
 *
 *    AUTHOR:        Kim Fallon
 *
 *    DATE CREATED:  03/05/99
 *
 *    HISTORY:
 *
 *       03/05/99    Initial Development
 *
$Log: C:/Symbol/Csp32Proj/Csp32/src/vcs/Csp32.cpv $
 *******************************************************************/
/*******************************************************************
 * MODIFICACION HECHA POR PERSONAL DE COMPUSCIENS
 *
 * TODO EL TRABAJO FUE DESARROLLADO ORIGINALMENTE POR EL O LOS PARTICIPANTES
 * ESPECIFICADOS EN LA NOTA SUPERIOR A ESTA.
 *
 * PROYECTO TRANSPORTE UCV - 19/06/2014
 *
 ******************************************************************/


#include "csp32bridge.h"

Csp32Bridge::Csp32Bridge(QObject *parent) : QObject(parent)
{
    nCspActivePort= -1; // Ningun puerto seleccionado
    nCspDeviceStatus= -1; // No hay un estado actual
    nCspProtocolVersion= -1; // No hay version del protocolo disponible
    nCspSystemStatus= -1; // No hay estado del sistema disponible

    nCspStoredBarcodes= 0; // Numeros de codigos de Barras almacenados
    nCspRetryCount= 5; // Numero por default de interrogaciones al dispositivo
}

/** Y ACA EMPIEZAN TODOS LOS METODOS NECESARIOS PARA LA COMUNICACION CON EL LECTOR **/
/** **/
/** **/

/* Esta funcion lee un caracter del puerto serial activo, si el puerto serial
 * no tiene un caracter dentro de MAXTIME, la funcion retorna un error de comunicacion
 *
 * Retorna el caracter leido o COMMUNICATIONS_ERROR
 */
int Csp32Bridge::cspGetc()
{
    int i;
    int  chRead;

    // Aseguremonos que se ha escogido un puerto
    if (nCspActivePort >= COM1)
    {
        // Podemos leer datos de el?
        for (i = 0; i < MAXTIME; i++)
        {
            // Tratemos de leer un caracter
            if ((chRead = SioGetc(nCspActivePort)) != WSC_NO_DATA)
            {
                return((int) chRead);
            }

            // Dejemos que otras tareas se ejecuten mientras esperamos por el lector
            Sleep(50);
        }
    }

    // Si llegamos hasta aca, ningun caracter pudo leerse, asi que...
    return (COMMUNICATIONS_ERROR);
}

/* Lrc es un metodo de deteccion de errores, esta funcion se encarga de
 * calcular el codigo LRC y retornarlo */
char Csp32Bridge::cspLrcCheck(char aLrcBytes[], int nMaxLength)
{
    int i;
    unsigned char chLrc = 0;        // inicializemos el valor del LRC

    // Calculemos el LRC del string completo
    for (i = 0; i < nMaxLength; i++)
        chLrc ^= aLrcBytes[i];

    return(chLrc);
}

/* Invalida o inicializa todos los valores usados por la clases
 * Probablemente usada despues de la configuracion de un nuevo puerto
 * COM
 */
void Csp32Bridge::cspInitParms()
{
    nCspActivePort= -1; // Ningun puerto seleccionado
    nCspDeviceStatus= -1; // No hay un estado actual
    nCspProtocolVersion= -1; // No hay version del protocolo disponible
    nCspSystemStatus= -1; // No hay estado del sistema disponible

    nCspStoredBarcodes= 0; // Numeros de codigos de Barras almacenados
}

/* Esta funcion maneja el overhead asociado al envio de comandos al dispositivo
 * CSP (Interrogation, Read Barcodes, Clear Barcodes, etc). */
int Csp32Bridge::cspSendCommand (char *aCommand, int nMaxLength)
{
    int i;

    // Aseguremonos que tenemos un puerto seleccionado valido
    if (nCspActivePort < COM1)
        return( COMMUNICATIONS_ERROR );

    // Un tiempo antes de enviar el mensaje
    Sleep ( 120 );

    // Limpiemos la cola de recepcion
    while (SioGetc(nCspActivePort) >= 0);

    // Enviemos el string con el comando
    for ( i = 0; i < nMaxLength; i++)
    {
        SioPutc(nCspActivePort, aCommand[i]);
    }

    // Esperemos la respuesta
    nCspDeviceStatus  = cspGetc();
    aByteBuffer[0] = (char) nCspDeviceStatus;

    // Conversion del estado del dispositivo a los estados definidos en el .h
    nCspDeviceStatus *= -1;

    // Si no hay una respuesta, retornemos un error
    if ( nCspDeviceStatus > 0 )
        return( COMMUNICATIONS_ERROR );

    if ( nCspDeviceStatus != NO_ERROR_ENCOUNTERED )
        return ( nCspDeviceStatus );
    else
        return ( STATUS_OK );
}


// FUNCIONES DE COMUNICACION

/* Esta funcion abre el puerto de comunicaciones especificado por
 * nComPort. Ademas de esto, inicializa todas las estructuras requeridas
 * para el funcionamiento de la comunicacion con el lector. */

int Csp32Bridge::cspInit(int nComPort)
{
    // El usuario trata de abrir un puerto valido?
    if (nComPort >= COM1)
    {
        // Cierra cualquier otro puerto abierto previamente
        if (nCspActivePort >= COM1)
            cspRestore();

        // Ahora tratamos de inicializar el puerto escogido
        if (SioReset(nComPort, RX_QUE_SIZE, TX_QUE_SIZE) < 0)
        {
            // Esto ocurrira si ningun puerto esta activo
            return(nCspActivePort = COMMUNICATIONS_ERROR);
        }
        else
        {
            // En caso contrario, el nuevo puerto activo sera el escogido...
            nCspActivePort = nComPort;
        }

        // Establece los parametros del puerto para asegurar la compatibilidad con el lector
        SioParms(nCspActivePort, OddParity, OneStopBit, WordLength8);
        SioBaud(nCspActivePort, Baud2400);
        SioDTR(nCspActivePort, SET_LINE);
        SioRTS(nCspActivePort, SET_LINE);
        return (STATUS_OK);
    }

    return (BAD_PARAM);
}


/* Esta funcion trata de cerrar cualquier conexion anteriormente abierta */
int Csp32Bridge::cspRestore()
{
    int nRetStatus = COMMUNICATIONS_ERROR;

    // are we attempting to close a valid port?
    if (nCspActivePort >= COM1)
    {
        // close any previously opened ports...
        nRetStatus = SioDone(nCspActivePort);
    }

    // initialize the dll interface...
    cspInitParms();

    // return status...
    if (nRetStatus < 0)
        return (COMMUNICATIONS_ERROR);
    else
        return (STATUS_OK);
}

// FUNCIONES BASICAS

/* Esta funcion se encarga de leer los codigos escaneados, el id del dispositivo y la firma
 * del mismo. */
int Csp32Bridge::cspReadData()
{
    int nRetStatus;

    // read the data from the CSP device
    nRetStatus = cspReadRawData(NULL, DETERMINE_SIZE);

    // if response not available, reply with error
    if ( nRetStatus < 0 )
        return ( nRetStatus );

    return( nCspStoredBarcodes );
}

/* Esta funcion limpia todos los codigos guardados en el lector */
char aClearBarCodesCmd[] =
{
    CLEAR_BAR_CODES,         // Comando de limpieza de codigos
    STX,                     // Condigo de opcion
    0x00,                    // Caracter nulo para cerrar el mensaje
    0x00                     // LRC
};

int Csp32Bridge::cspClearBarCodes()
{
    int i;
    int nRetStatus;

    // Revisemos que el lector este conectado...
    if ((nRetStatus = cspInterrogate()) != STATUS_OK)
        return( nRetStatus );

    // Enviemos el comando al lector.s..
    nRetStatus = cspSendCommand (aClearBarCodesCmd, sizeof(aClearBarCodesCmd));

    if ( nRetStatus != STATUS_OK )
        return ( nRetStatus );

    // Hasta aqui todo bien, obtengamos el mensaje entero...
    i = 1;

    // Obtengamos el caracter de opcion (STX)
    aByteBuffer[i++] = (char) cspGetc();

    // Obtengamos el caracter nulo
    aByteBuffer[i++] = (char) cspGetc();

    // Verifiquemos el LRC...
    aByteBuffer[i] = cspLrcCheck(aByteBuffer, i);
    if ( aByteBuffer[i] != (char) cspGetc())
        return( COMMAND_LRC_ERROR );

    return( STATUS_OK );
}


/** **/
/** **/
/** ACA TERMINAN DICHOS METODOS E INICIA CUALQUIERA DE LOS NECESARIOS PARA QT Y SU OBJETO **/

